ğŸ“Œ Function = block of code we can reuse

âœ… Declaration:
function greet(name) {
  console.log("Hello " + name);
}

âœ… Call:
greet("Rudra");

âœ… Parameters = values function expects
âœ… Arguments = values we pass when calling

ğŸ“Œ Return:
function add(a, b) {
  return a + b;
}

let sum = add(2, 3); // 5

ğŸ“Œ Function expressions:
const sayHi = function(name) {
  return "Hi " + name;
};

ğŸ“Œ Arrow function:
const square = (n) => n * n;

ğŸ“Œ Function inside function = allowed

âœ… Functions are first-class citizens in JS
- Stored in variables
- Passed as arguments
- Returned from other functions

1ï¸âƒ£ Arrow Functions
ğŸ“Œ Shorter syntax for functions

ğŸ“Œ Syntax:
const add = (a, b) => a + b;

ğŸ“Œ One param:
n => n * n

ğŸ“Œ No param:
() => "Hello!"

ğŸ“Œ With block:
(x) => {
  const y = x * 2;
  return y;
}

âš ï¸ No `this`, `arguments`, `super`, or `new.target`

ğŸ“Œ Arrow functions donâ€™t get their own `this`
- They use the `this` of the outer scope (lexical `this`)

âœ… Use arrow functions for:
- Callbacks
- Shorter syntax
- Keeping `this` from parent


2ï¸âƒ£ Hoisting

ğŸ“Œ Hoisting = JS moves declarations to top of their scope

âœ… Function declarations are fully hoisted
- Can call before they appear in code

âœ… var â†’ hoisted + initialized as undefined
âŒ let/const â†’ hoisted but NOT initialized (TDZ error)

Example:
console.log(a); // undefined
var a = 10;

console.log(b); // âŒ ReferenceError
let b = 20;

function test() {
  console.log("Hello"); // works even if called before
}

3ï¸âƒ£ Scoping

ğŸ“Œ Scope = where a variable can be accessed

1. Global Scope:
let x = 10; // accessible everywhere

2. Function Scope:
function sayHi() {
  let name = "Rudra"; // only inside function
}

3. Block Scope:
if (true) {
  let a = 5; // only inside if block
}

ğŸ“Œ var = function scoped
ğŸ“Œ let/const = block scoped

ğŸ§  Nested scopes:
function outer() {
  let a = 1;
  function inner() {
    console.log(a); // can access outer scope
  }
  inner();
}
